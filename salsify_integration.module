<?php

/**
 * @file
 * The Salsify integration module.
 */

use \Drupal\Core\Entity\EntityInterface;
use \Drupal\Core\Entity\FieldableEntityInterface;
use \Drupal\Core\Field\FieldStorageDefinitionInterface;
use \Drupal\field\Entity\FieldStorageConfig;
use \Drupal\salsify_integration\SalsifyMultiField;
use \Drupal\salsify_integration\SalsifySingleField;

/**
 * The cron job definition to kick off the midnight Salsify import process.
 */
function salsify_integration_midnight_import($job) {
  $container = \Drupal::getContainer();
  $config = \Drupal::config('salsify_integration.settings');
  switch ($config->get('import_method')) {
    case 'serialized':
      $product_feed = SalsifySingleField::create($container);
      $product_feed->importProductData();
      \Drupal::logger('salsify_integration')->notice('The Salsify data is queue to be imported and will be processed on the next cron run.');
      break;

    case 'fields':
      $product_feed = SalsifyMultiField::create($container);
      $product_feed->importProductData();
      \Drupal::logger('salsify_integration')->notice('The Salsify data is queue to be imported and will be processed on the next cron run.');
      break;
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * @see options_allowed_values()
 */
function salsify_integration_allowed_values_callback(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL) {
  $options_config = \Drupal::config('salsify_integration.field_options');
  $salsify_id = salsify_integration_get_salsify_id($definition->getName());
  $options = $options_config->get($salsify_id[0]);
  if ($options) {
    return $options;
  }
  return [];
}

/**
 * Looks up a Drupal field's Salsify ID from the mapping table.
 */
function salsify_integration_get_salsify_id($field_name) {
  return \Drupal::database()->select('salsify_field_data', 'f')
    ->fields('f', array('field_id'))
    ->condition('field_name', $field_name, '=')
    ->range(0, 1)
    ->execute()
    ->fetchCol('field_id');
}

/**
 * Utility function to clean up Salsify data if fields are deleted from Drupal.
 */
function salsify_integration_field_config_delete(EntityInterface $field) {
  // Get the field name and use it to look up the field_id from the mapping
  // table.
  $field_name = $field->get('field_name');
  $field_storage = FieldStorageConfig::loadByName('node', $field_name);

  if ($field_storage) {
    // If the field is still set somewhere on the system, then don't remove it
    // and leave the field mapping intact.
    $bundles = $field_storage->getBundles();

    if (empty($bundles)) {
      $field_id = salsify_integration_get_salsify_id($field_name)[0];
      $container = \Drupal::getContainer();
      // Perform the deletion logic on the Salsify data.
      $salsify = SalsifyMultiField::create($container);
      $salsify->removeFieldOptions($field_id);
      $salsify->deleteFieldMapping('field_id', $field_id);
    }
  }
}

/**
 * Implements hook_theme().
 */
function salsify_integration_theme() {
  return array(
    // Normally theme suggestion templates are only picked up when they are in
    // themes. Define theme suggestions here so that the block templates in
    // the templates directory are picked up.
    'salsify_field' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field',
      'template' => 'salsify-field',
    ],
    'salsify_field__boolean' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--boolean',
    ],
    'salsify_field__link' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--link',
    ],
    'salsify_field__html' => [
      'render element' => 'salsify_fields',
      'pattern' => 'salsify_field__',
      'template' => 'salsify-field--html',
    ],
  );
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Adds preprocess logic for serialized Salsify data.
 */
function salsify_integration_preprocess_node__model(&$variables) {

  // Create a few setup variables.
  /* @var \Drupal\node\Entity\Node $entity */
  $entity = $variables['elements']['#node'];
  $config = \Drupal::config('salsify_integration.settings');
  $import_method = $config->get('import_method');
  if ($import_method == 'serialized') {
    $field_mapping = SalsifySingleField::getFieldMappings();
    if (isset($field_mapping['salsifysync_data'])) {
      $field_data = unserialize($field_mapping['salsifysync_data']->data);
      $variables['salsify_fields'] = salsify_integration_setup_field_render_arrays($field_data);
      if (!$entity->salsifysync_data->isEmpty()) {
        $product_data = $entity->get('salsifysync_data')->value;
        salsify_integration_setup_value_render_arrays($variables['salsify_fields'], unserialize($product_data));
      }
    }
  }
}

/**
 * Helper function that adds the proper theme handler for each Salsify field.
 */
function salsify_integration_setup_field_render_arrays(array $field_data) {
  $render_array = [];
  foreach ($field_data as $id => $field) {
    $field_array = [
      'title' => [
        '#value' => t('@title', ['@title' => $field['salsify:name']]),
        '#attributes' => [
          'class' => ['field-title'],
        ],
      ],
      '#theme' => 'salsify_field',
    ];
    switch ($field['salsify:data_type']) {
      case 'boolean':
        $field_array['#theme'] = 'salsify_field__boolean';
        break;

      case 'html':

      case 'rich_text':
        $field_array['#theme'] = 'salsify_field__html';
        break;

      case 'link':
        $field_array['#theme'] = 'salsify_field__link';
        break;

    }
    $render_array[$id] = $field_array;
  }
  return $render_array;
}

/**
 * Helper function that adds the field values into the provided render array.
 */
function salsify_integration_setup_value_render_arrays(array &$field_data, array $product_data) {
  foreach ($field_data as $key => &$field) {
    $field['field_value'] = [
      '#value' => isset($product_data[$key]) ? $product_data[$key] : '',
    ];
  }
}
